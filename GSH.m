(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



(* ::Input::Initialization:: *)
(*One needs to evaluate the TensorCosmetics notebook before evaluating this notebook*)
BeginPackage["GSH`",{"TensorCosmetics`"}];
Unprotect@@Names["GSH`*"];
ClearAll@@Names["GSH`*"];

GSHUnitVector::usage=
"GSHUnitVector[] returns the unit vectors \!\(\*SubscriptBox[\(e\), \(-\)]\),\!\(\*SubscriptBox[\(e\), \(\(0\)\(,\)\)]\)\!\(\*SubscriptBox[\(e\), \(+\)]\) as three entries of a rank 2 tensor.
It does not admit any argument.";
SpheInt::usage=
"SpheInt[l1_,l2_,l3_,m1_,m2_,m3_,n1_,n2_,n3_] is used to retrieve the symbolic form of the corresponding GSH integral with the first GSH being conjugated. The results is in terms of the required Wigner-3j's.";
ThreeJ::usage=
"ThreeJ[l1_,l2_,l3_,m1_,m2_,m3_] is used to retrieve the symbolic form of a Wigner-3j";
Shift::usage=
"Shift[T_,q_,r_] returns tensor T wirh entries shifted by q places in r'th index, putting 0's for emergent entries."; 
GradGSH::usage=
"GradGSH[T_,l_] returns gradient of tensor T with harmonic order l. rank[gradient] = rank[T]+1";
Om::usage=
"Om[l_,m_] finds the value \!\(\*SqrtBox[\(\*FractionBox[\(1\), \(2\)] \((l \[PlusMinus] N)\) \((\(l \[MinusPlus] N\) + 1)\)\)]\) " ;
r::usage="r";

Begin["`Private`"];

GSHUnitVector[] := {1/Sqrt[2] {0,1,-I},{1,0,0},1/Sqrt[2] {0,-1,-I}};

SpheInt[l1_,l2_,l3_,m1_,m2_,m3_,n1_,n2_,n3_]:=(-1)^(m1+n1) ThreeJ[l1,l2,l3,-n1,n2,n3]ThreeJ[l1,l2,l3,-m1,m2,m3];

ThreeJ[l1_,l2_,l3_,m1_,m2_,m3_]:=Module[{ret},ret=0;
ret=MatrixForm[{{l1,l2,l3},{m1,m2,m3}}];
Return[ret];
]

Om[l_,m_]:=
If[m<0||m==1,Om[l,-m+1],Subscript[Global`\[CapitalOmega], ToString[l]<>ToString[m]]];

Shift[T_,q_,r_]:=Module[{i,dim,rank,len,ind,Tf,Tnew,shape,m},
shape=Dimensions[T];
dim=shape[[1]];
rank=Length[shape];
If[r>rank,Return["r exceeds rank of tensor"]];
If[Total[shape]-dim*rank!=0,Return["input array has nonuniform dimensionality"]];
Tf=Flatten[T];
len=Length[Tf];
Tnew=Array[0&,len];
For[m=1,m<=len,m++,
ind=IntegerDigits[m-1,dim,rank]+1;
i=ind[[r]];
If[i-q<=0||i-q>dim,Tnew[[m]]=0,Tnew[[m]]=Tf[[m-q*dim^(rank-r)]]];
];
Return[ArrayReshape[Tnew,shape]];
]

$Assumptions=r>0;
GradGSH[T_,l_]:=Module[{a,rad,ang,rank,omega1,omega2},
(*Returns gradient of tensor T with harmonic order l. rank[gradient] = rank[T]+1*)
rank=Length[Dimensions[T]];
rad=TensorProduct[UnitTensor[2],D[T,r]];(*radial part of gradient*)
omega1=Array[Om[l,Total[{##}]-2*rank]&,Dimensions[T]];
omega2=Array[Om[l,-(Total[{##}]-2*rank)]&,Dimensions[T]];
ang=TensorProduct[UnitTensor[1],omega1*T];(*angular part of gradient*)
ang+=TensorProduct[UnitTensor[3],omega2*T];
For[a=1,a<=rank,a++,
ang-=TensorProduct[UnitTensor[1],Shift[T,1,a]];
ang-=TensorProduct[UnitTensor[3],Shift[T,-1,a]];
];
Return[rad+ang/r];
]

End[];
Protect@@Names["GSH`*"];
EndPackage[];



